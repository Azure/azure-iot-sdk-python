# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import SDKClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from . import models


class ProvisioningServiceClientConfiguration(Configuration):
    """Configuration for ProvisioningServiceClient
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(self, credentials, base_url=None):

        if credentials is None:
            raise ValueError("Parameter 'credentials' must not be None.")
        if not base_url:
            base_url = "https://your-dps.azure-devices-provisioning.net"

        super(ProvisioningServiceClientConfiguration, self).__init__(base_url)

        self.add_user_agent("provisioningserviceclient/{}".format(VERSION))

        self.credentials = credentials


class ProvisioningServiceClient(SDKClient):
    """API for service operations with the Azure IoT Hub Device Provisioning Service

    :ivar config: Configuration for client.
    :vartype config: ProvisioningServiceClientConfiguration

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(self, credentials, base_url=None):

        self.config = ProvisioningServiceClientConfiguration(credentials, base_url)
        super(ProvisioningServiceClient, self).__init__(self.config.credentials, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = "2019-05-01"
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)

    def get_certificate_authority(self, name, custom_headers=None, raw=False, **operation_config):
        """Get a certificate authority. This operation requires the
        certificateAuthority/read permission.

        :param name: The certificate authority name. A Case-insensitive string
         (up to 128 characters long) of ASCII 7-bit alphanumeric characters
         plus certain special characters : . _ -. No special characters allowed
         at start or end.
        :type name: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CertificateAuthority or ClientRawResponse if raw=true
        :rtype: ~protocol.models.CertificateAuthority or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.get_certificate_authority.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("CertificateAuthority", response)
            header_dict = {"ETag": "str"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    get_certificate_authority.metadata = {"url": "/certificateAuthorities/{name}"}

    def create_or_replace_certificate_authority(
        self,
        name,
        certificate_authority,
        if_match=None,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Create or replace a certificate authority with the specified
        certificate authority source type. This operation requires the
        certificateAuthority/write permission.

        :param name: The desired certificate authority name. A
         Case-insensitive string (up to 128 characters long) of ASCII 7-bit
         alphanumeric characters plus certain special characters : . _ -. No
         special characters allowed at start or end.
        :type name: str
        :param certificate_authority: The created certificate authority
         object.
        :type certificate_authority: ~protocol.models.CertificateAuthority
        :param if_match: The ETag of the certificate authority.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CertificateAuthority or ClientRawResponse if raw=true
        :rtype: ~protocol.models.CertificateAuthority or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.create_or_replace_certificate_authority.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if if_match is not None:
            header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct body
        body_content = self._serialize.body(certificate_authority, "CertificateAuthority")

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize("CertificateAuthority", response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    create_or_replace_certificate_authority.metadata = {"url": "/certificateAuthorities/{name}"}

    def delete_certificate_authority(
        self, name, if_match, custom_headers=None, raw=False, **operation_config
    ):
        """Delete the certificate authority. This operation requires the
        certificateAuthority/delete permission.

        :param name: The certificate authority name. A Case-insensitive string
         (up to 128 characters long) of ASCII 7-bit alphanumeric characters
         plus certain special characters : . _ -. No special characters allowed
         at start or end.
        :type name: str
        :param if_match: The ETag of the certificate authority.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.delete_certificate_authority.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    delete_certificate_authority.metadata = {"url": "/certificateAuthorities/{name}"}

    def get_device_group(self, name, custom_headers=None, raw=False, **operation_config):
        """Get a device group. This operation requires the deviceGroup/read
        permission.

        :param name: Name of the device group. A Case-insensitive string (up
         to 128 characters long) of ASCII 7-bit alphanumeric characters plus
         certain special characters : . _ -. No special characters allowed at
         start or end.
        :type name: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DeviceGroup or ClientRawResponse if raw=true
        :rtype: ~protocol.models.DeviceGroup or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.get_device_group.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("DeviceGroup", response)
            header_dict = {"ETag": "str"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    get_device_group.metadata = {"url": "/deviceGroups/{name}"}

    def create_or_replace_device_group(
        self, name, device_group, if_match=None, custom_headers=None, raw=False, **operation_config
    ):
        """Create or replace the device group. This operation requires the
        deviceGroup/write permission.

        :param name: Name of the device group. A Case-insensitive string (up
         to 128 characters long) of ASCII 7-bit alphanumeric characters plus
         certain special characters : . _ -. No special characters allowed at
         start or end.
        :type name: str
        :param device_group: The device group.
        :type device_group: ~protocol.models.DeviceGroup
        :param if_match: The ETag of the device group.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DeviceGroup or ClientRawResponse if raw=true
        :rtype: ~protocol.models.DeviceGroup or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.create_or_replace_device_group.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if if_match is not None:
            header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct body
        body_content = self._serialize.body(device_group, "DeviceGroup")

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize("DeviceGroup", response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    create_or_replace_device_group.metadata = {"url": "/deviceGroups/{name}"}

    def delete_device_group(
        self, name, if_match, custom_headers=None, raw=False, **operation_config
    ):
        """Delete the device group. This operation requires the
        deviceGroups/delete permission.

        :param name: Name of the device group. A Case-insensitive string (up
         to 128 characters long) of ASCII 7-bit alphanumeric characters plus
         certain special characters : . _ -. No special characters allowed at
         start or end.
        :type name: str
        :param if_match: The ETag of the device group.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.delete_device_group.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    delete_device_group.metadata = {"url": "/deviceGroups/{name}"}

    def get_device_record(
        self,
        device_group_name,
        device_id,
        expand=None,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Get a device authentication record. This operation requires the
        deviceGroup/read or deviceGroup/write permission.

        :param device_group_name: Name of the device group. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end.
        :type device_group_name: str
        :param device_id: The device ID. A Case-insensitive string (up to 128
         characters long) of ASCII 7-bit alphanumeric characters plus certain
         special characters : . _ -. No special characters allowed at start or
         end.
        :type device_id: str
        :param expand: Properties to optionally expand in response. Possible
         values include: 'symmetricKey', 'x509Certificate', 'all'
        :type expand: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DeviceRecord or ClientRawResponse if raw=true
        :rtype: ~protocol.models.DeviceRecord or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.get_device_record.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str"),
            "deviceId": self._serialize.url("device_id", device_id, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if expand is not None:
            query_parameters["$expand"] = self._serialize.query("expand", expand, "str")
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("DeviceRecord", response)
            header_dict = {"ETag": "str"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    get_device_record.metadata = {"url": "/deviceGroups/{deviceGroupName}/deviceRecords/{deviceId}"}

    def create_or_replace_device_record(
        self,
        device_group_name,
        device_id,
        device_record,
        if_match=None,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Create or replace the device authentication record. This operation
        requires the deviceGroup/write permission.

        :param device_group_name: Name of the device group. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end.
        :type device_group_name: str
        :param device_id: The device ID. A Case-insensitive string (up to 128
         characters long) of ASCII 7-bit alphanumeric characters plus certain
         special characters : . _ -. No special characters allowed at start or
         end.
        :type device_id: str
        :param device_record: The device Record.
        :type device_record: ~protocol.models.DeviceRecord
        :param if_match: The ETag of the device Record.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DeviceRecord or ClientRawResponse if raw=true
        :rtype: ~protocol.models.DeviceRecord or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.create_or_replace_device_record.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str"),
            "deviceId": self._serialize.url("device_id", device_id, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if if_match is not None:
            header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct body
        body_content = self._serialize.body(device_record, "DeviceRecord")

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize("DeviceRecord", response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    create_or_replace_device_record.metadata = {
        "url": "/deviceGroups/{deviceGroupName}/deviceRecords/{deviceId}"
    }

    def delete_device_record(
        self,
        device_group_name,
        device_id,
        if_match,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Delete the device record. This operation requires the
        deviceGroups/delete permission.

        :param device_group_name: Name of device group. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end.
        :type device_group_name: str
        :param device_id: The device ID. A Case-insensitive string (up to 128
         characters long) of ASCII 7-bit alphanumeric characters plus certain
         special characters : . _ -. No special characters allowed at start or
         end.
        :type device_id: str
        :param if_match: The ETag of the device record.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.delete_device_record.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str"),
            "deviceId": self._serialize.url("device_id", device_id, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    delete_device_record.metadata = {
        "url": "/deviceGroups/{deviceGroupName}/deviceRecords/{deviceId}"
    }

    def get_group_record(
        self,
        device_group_name,
        name,
        expand=None,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Get a group authentication record. This operation requires the
        deviceGroup/read or deviceGroup/write permission.

        :param device_group_name: Name of the device group. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end.
        :type device_group_name: str
        :param name: Name of the group record. A Case-insensitive string (up
         to 128 characters long) of ASCII 7-bit alphanumeric characters plus
         certain special characters : . _ -. No special characters allowed at
         start or end.
        :type name: str
        :param expand: Properties to optionally expand in response. If not
         specified the service will not expand the optional properties.
         Possible values include: 'symmetricKey', 'x509Certificate', 'all'
        :type expand: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupRecord or ClientRawResponse if raw=true
        :rtype: ~protocol.models.GroupRecord or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.get_group_record.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str"),
            "name": self._serialize.url("name", name, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if expand is not None:
            query_parameters["$expand"] = self._serialize.query("expand", expand, "str")
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("GroupRecord", response)
            header_dict = {"ETag": "str"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    get_group_record.metadata = {"url": "/deviceGroups/{deviceGroupName}/groupRecords/{name}"}

    def create_or_replace_group_record(
        self,
        device_group_name,
        name,
        group_record,
        if_match=None,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Create or replace the group authentication record. This operation
        requires the deviceGroup/write permission.

        :param device_group_name: Name of the device group. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end.
        :type device_group_name: str
        :param name: Name of the group record. A Case-insensitive string (up
         to 128 characters long) of ASCII 7-bit alphanumeric characters plus
         certain special characters : . _ -. No special characters allowed at
         start or end.
        :type name: str
        :param group_record: The group record.
        :type group_record: ~protocol.models.GroupRecord
        :param if_match: The ETag of the group record.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupRecord or ClientRawResponse if raw=true
        :rtype: ~protocol.models.GroupRecord or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.create_or_replace_group_record.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str"),
            "name": self._serialize.url("name", name, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if if_match is not None:
            header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct body
        body_content = self._serialize.body(group_record, "GroupRecord")

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize("GroupRecord", response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    create_or_replace_group_record.metadata = {
        "url": "/deviceGroups/{deviceGroupName}/groupRecords/{name}"
    }

    def delete_group_record(
        self, device_group_name, name, if_match, custom_headers=None, raw=False, **operation_config
    ):
        """Delete the group record. This operation requires the
        deviceGroups/delete permission.

        :param device_group_name: Name of device group. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end.
        :type device_group_name: str
        :param name: Name of group record. A Case-insensitive string (up to
         128 characters long) of ASCII 7-bit alphanumeric characters plus
         certain special characters : . _ -. No special characters allowed at
         start or end.
        :type name: str
        :param if_match: The ETag of the group record.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.delete_group_record.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str"),
            "name": self._serialize.url("name", name, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    delete_group_record.metadata = {"url": "/deviceGroups/{deviceGroupName}/groupRecords/{name}"}

    def get_linked_hub(self, name, custom_headers=None, raw=False, **operation_config):
        """Get a linked hub. This operation requires the linkedHubs/read
        permission.

        :param name: Name of the linked hub. A Case-insensitive string (up to
         128 characters long) of ASCII 7-bit alphanumeric characters plus
         certain special characters : . _ -. No special characters allowed at
         start or end.
        :type name: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LinkedHub or ClientRawResponse if raw=true
        :rtype: ~protocol.models.LinkedHub or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.get_linked_hub.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("LinkedHub", response)
            header_dict = {"ETag": "str"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    get_linked_hub.metadata = {"url": "/linkedHubs/{name}"}

    def create_or_replace_linked_hub(
        self, name, linked_hub, if_match=None, custom_headers=None, raw=False, **operation_config
    ):
        """Create or replace the linked hub. This operation requires the
        linkedHubs/write permission.

        :param name: Name of the linked hub. A Case-insensitive string (up to
         128 characters long) of ASCII 7-bit alphanumeric characters plus
         certain special characters : . _ -. No special characters allowed at
         start or end..
        :type name: str
        :param linked_hub: The linked hub.
        :type linked_hub: ~protocol.models.LinkedHub
        :param if_match: The ETag of the linked hub.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LinkedHub or ClientRawResponse if raw=true
        :rtype: ~protocol.models.LinkedHub or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.create_or_replace_linked_hub.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if if_match is not None:
            header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct body
        body_content = self._serialize.body(linked_hub, "LinkedHub")

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize("LinkedHub", response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    create_or_replace_linked_hub.metadata = {"url": "/linkedHubs/{name}"}

    def delete_linked_hub(self, name, if_match, custom_headers=None, raw=False, **operation_config):
        """Delete the linked hub record.

        :param name: Name of the linked hub. A Case-insensitive string (up to
         128 characters long) of ASCII 7-bit alphanumeric characters plus
         certain special characters : . _ -. No special characters allowed at
         start or end.
        :type name: str
        :param if_match: The ETag of the linked hub record.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.delete_linked_hub.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    delete_linked_hub.metadata = {"url": "/linkedHubs/{name}"}

    def get_provisioning_settings(self, name, custom_headers=None, raw=False, **operation_config):
        """Get a provisioning settings. This operation requires the
        provisioningSettings/read or provisioningSettings/write permissions.

        :param name: Name of the provisioning settings. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end.
        :type name: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ProvisioningSettings or ClientRawResponse if raw=true
        :rtype: ~protocol.models.ProvisioningSettings or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.get_provisioning_settings.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("ProvisioningSettings", response)
            header_dict = {"ETag": "str"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    get_provisioning_settings.metadata = {"url": "/provisioningSettings/{name}"}

    def create_or_replace_provisioning_settings(
        self,
        name,
        provisioning_settings,
        if_match=None,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Create or replace the provisioning settings. This operation requires
        the provisioningSettings/write permission.

        :param name: Name of the provisioning settings. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end..
        :type name: str
        :param provisioning_settings: The provisioning settings.
        :type provisioning_settings: ~protocol.models.ProvisioningSettings
        :param if_match: The ETag of the provisioning settings.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ProvisioningSettings or ClientRawResponse if raw=true
        :rtype: ~protocol.models.ProvisioningSettings or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.create_or_replace_provisioning_settings.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if if_match is not None:
            header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct body
        body_content = self._serialize.body(provisioning_settings, "ProvisioningSettings")

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize("ProvisioningSettings", response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    create_or_replace_provisioning_settings.metadata = {"url": "/provisioningSettings/{name}"}

    def delete_provisioning_settings(
        self, name, if_match, custom_headers=None, raw=False, **operation_config
    ):
        """Delete the provisioning settings. This operation requires the
        provisioningSettings/delete permission.

        :param name: Name of the provisioning settings. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end.
        :type name: str
        :param if_match: The ETag of the provisioning settings.
        :type if_match: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.delete_provisioning_settings.metadata["url"]
        path_format_arguments = {"name": self._serialize.url("name", name, "str")}
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        header_parameters["If-Match"] = self._serialize.header("if_match", if_match, "str")

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    delete_provisioning_settings.metadata = {"url": "/provisioningSettings/{name}"}

    def get_provisioning_record(
        self, device_group_name, device_id, custom_headers=None, raw=False, **operation_config
    ):
        """Get a device provisioning record. This operation requires the
        deviceGroup/read permission.

        :param device_group_name: Name of device group. A Case-insensitive
         string (up to 128 characters long) of ASCII 7-bit alphanumeric
         characters plus certain special characters : . _ -. No special
         characters allowed at start or end.
        :type device_group_name: str
        :param device_id: The device ID. A Case-insensitive string (up to 128
         characters long) of ASCII 7-bit alphanumeric characters plus certain
         special characters : . _ -. No special characters allowed at start or
         end.
        :type device_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ProvisioningRecord or ClientRawResponse if raw=true
        :rtype: ~protocol.models.ProvisioningRecord or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.get_provisioning_record.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str"),
            "deviceId": self._serialize.url("device_id", device_id, "str"),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("ProvisioningRecord", response)
            header_dict = {"ETag": "str"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    get_provisioning_record.metadata = {
        "url": "/deviceGroups/{deviceGroupName}/provisioningRecords/{deviceId}"
    }

    def query_certificate_authorities(
        self, query, x_ms_max_item_count=None, custom_headers=None, raw=False, **operation_config
    ):
        """Retrieves a list of the certificate authorities and a continuation
        token to retrieve the next page. This operation requires the dps/read
        permission.

        :param query: The {QueryAll} to match the certificate authorities or
         {QueryNext} returned in response.
        :type query: ~protocol.models.Query
        :param x_ms_max_item_count: Maximum number of results to return in a
         page. If not specified with {QueryAll} the service will return up to
         100 results.
        :type x_ms_max_item_count: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CertificateAuthorityQueryResponse or ClientRawResponse if
         raw=true
        :rtype: ~protocol.models.CertificateAuthorityQueryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.query_certificate_authorities.metadata["url"]

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_ms_max_item_count is not None:
            header_parameters["x-ms-max-item-count"] = self._serialize.header(
                "x_ms_max_item_count", x_ms_max_item_count, "int"
            )

        # Construct body
        body_content = self._serialize.body(query, "Query")

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("CertificateAuthorityQueryResponse", response)
            header_dict = {"x-ms-max-item-count": "int"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    query_certificate_authorities.metadata = {"url": "/certificateAuthorities/query"}

    def query_device_groups(
        self, query, x_ms_max_item_count=None, custom_headers=None, raw=False, **operation_config
    ):
        """Retrieves a list of the device groups and a continuation token to
        retrieve the next page. This operation requires the deviceGroup/read
        permission.

        :param query: The {QueryAll} to match the device groups or {QueryNext}
         returned in response.
        :type query: ~protocol.models.Query
        :param x_ms_max_item_count: Maximum number of results to return in a
         page. If not specified with {QueryAll} the service will return up to
         100 results.
        :type x_ms_max_item_count: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DeviceGroupQueryResponse or ClientRawResponse if raw=true
        :rtype: ~protocol.models.DeviceGroupQueryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.query_device_groups.metadata["url"]

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_ms_max_item_count is not None:
            header_parameters["x-ms-max-item-count"] = self._serialize.header(
                "x_ms_max_item_count", x_ms_max_item_count, "int"
            )

        # Construct body
        body_content = self._serialize.body(query, "Query")

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("DeviceGroupQueryResponse", response)
            header_dict = {"x-ms-max-item-count": "int"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    query_device_groups.metadata = {"url": "/deviceGroups/query"}

    def query_device_records(
        self,
        device_group_name,
        query,
        x_ms_max_item_count=None,
        expand=None,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Retrieves a list of the device record in the specified device group and
        a continuation token to retrieve the next page. This operation requires
        the deviceGroup/read or deviceGroup/write permission.

        :param device_group_name: The device group in which the query
         operation is performed.
        :type device_group_name: str
        :param query: The {QueryAll} to match the device records or
         {QueryNext} returned in response.
        :type query: ~protocol.models.Query
        :param x_ms_max_item_count: Maximum number of results to return in a
         page. If not specified with {QueryAll} the service will return up to
         100 results.
        :type x_ms_max_item_count: int
        :param expand: Properties to optionally expand in the response. If not
         specified the service will not expand the optional properties.
         Possible values include: 'symmetricKey', 'x509Certificate', 'all'
        :type expand: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DeviceRecordQueryResponse or ClientRawResponse if raw=true
        :rtype: ~protocol.models.DeviceRecordQueryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.query_device_records.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str")
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if expand is not None:
            query_parameters["$expand"] = self._serialize.query("expand", expand, "str")
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_ms_max_item_count is not None:
            header_parameters["x-ms-max-item-count"] = self._serialize.header(
                "x_ms_max_item_count", x_ms_max_item_count, "int"
            )

        # Construct body
        body_content = self._serialize.body(query, "Query")

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("DeviceRecordQueryResponse", response)
            header_dict = {"x-ms-max-item-count": "int"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    query_device_records.metadata = {"url": "/deviceGroups/{deviceGroupName}/deviceRecords/query"}

    def query_group_records(
        self,
        device_group_name,
        query,
        x_ms_max_item_count=None,
        expand=None,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Retrieves a list of the group record in the specified device group and
        a continuation token to retrieve the next page. This operation requires
        the deviceGroup/read or deviceGroup/write permission.

        :param device_group_name: The device group in which the query
         operation is performed.
        :type device_group_name: str
        :param query: The {QueryAll} to match the group records or {QueryNext}
         returned in response.
        :type query: ~protocol.models.Query
        :param x_ms_max_item_count: Maximum number of results to return in a
         page. If not specified with {QueryAll} the service will return up to
         100 results.
        :type x_ms_max_item_count: int
        :param expand: Properties to optionally expand in the response. If not
         specified the service will not expand the optional properties.
         Possible values include: 'symmetricKey', 'x509Certificate', 'all'
        :type expand: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GroupRecordQueryResponse or ClientRawResponse if raw=true
        :rtype: ~protocol.models.GroupRecordQueryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.query_group_records.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str")
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if expand is not None:
            query_parameters["$expand"] = self._serialize.query("expand", expand, "str")
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_ms_max_item_count is not None:
            header_parameters["x-ms-max-item-count"] = self._serialize.header(
                "x_ms_max_item_count", x_ms_max_item_count, "int"
            )

        # Construct body
        body_content = self._serialize.body(query, "Query")

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("GroupRecordQueryResponse", response)
            header_dict = {"x-ms-max-item-count": "int"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    query_group_records.metadata = {"url": "/deviceGroups/{deviceGroupName}/groupRecords/query"}

    def query_linked_hubs(
        self, query, x_ms_max_item_count=None, custom_headers=None, raw=False, **operation_config
    ):
        """Retrieves a list of the linked IoTHubs and a continuation token to
        retrieve the next page. This operation requires the linkedHubs/read
        permission.

        :param query: The {QueryAll} to match the linked IoTHubs or
         {QueryNext} returned in response.
        :type query: ~protocol.models.Query
        :param x_ms_max_item_count: Maximum number of results to return in a
         page. If not specified with {QueryAll} the service will return up to
         100 results.
        :type x_ms_max_item_count: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LinkedHubQueryResponse or ClientRawResponse if raw=true
        :rtype: ~protocol.models.LinkedHubQueryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.query_linked_hubs.metadata["url"]

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_ms_max_item_count is not None:
            header_parameters["x-ms-max-item-count"] = self._serialize.header(
                "x_ms_max_item_count", x_ms_max_item_count, "int"
            )

        # Construct body
        body_content = self._serialize.body(query, "Query")

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("LinkedHubQueryResponse", response)
            header_dict = {"x-ms-max-item-count": "int"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    query_linked_hubs.metadata = {"url": "/linkedHubs/query"}

    def query_provisioning_records(
        self,
        device_group_name,
        query,
        x_ms_max_item_count=None,
        custom_headers=None,
        raw=False,
        **operation_config
    ):
        """Retrieves a list of the provisioning records and a continuation token
        to retrieve the next page. This operation requires the deviceGroup/read
        permission.

        :param device_group_name: The device group in which the query
         operation is performed.
        :type device_group_name: str
        :param query: The {QueryAll} to match the provisioning records or
         {QueryNext} returned in response.
        :type query: ~protocol.models.Query
        :param x_ms_max_item_count: Maximum number of results to return in a
         page. If not specified with {QueryAll} the service will return up to
         100 results.
        :type x_ms_max_item_count: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ProvisioningRecordQueryResponse or ClientRawResponse if
         raw=true
        :rtype: ~protocol.models.ProvisioningRecordQueryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.query_provisioning_records.metadata["url"]
        path_format_arguments = {
            "deviceGroupName": self._serialize.url("device_group_name", device_group_name, "str")
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_ms_max_item_count is not None:
            header_parameters["x-ms-max-item-count"] = self._serialize.header(
                "x_ms_max_item_count", x_ms_max_item_count, "int"
            )

        # Construct body
        body_content = self._serialize.body(query, "Query")

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("ProvisioningRecordQueryResponse", response)
            header_dict = {"x-ms-max-item-count": "int"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    query_provisioning_records.metadata = {
        "url": "/deviceGroups/{deviceGroupName}/provisioningRecords/query"
    }

    def query_provisioning_settings(
        self, query, x_ms_max_item_count=None, custom_headers=None, raw=False, **operation_config
    ):
        """Retrieves a list of the provisioning settings and a continuation token
        to retrieve the next page. This operation requires the
        provisioningSettings/read permission.

        :param query: The {QueryAll} to match the provisioning settings or
         {QueryNext} returned in response.
        :type query: ~protocol.models.Query
        :param x_ms_max_item_count: Maximum number of results to return in a
         page. If not specified with {QueryAll} the service will return up to
         100 results.
        :type x_ms_max_item_count: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ProvisioningSettingsQueryResponse or ClientRawResponse if
         raw=true
        :rtype: ~protocol.models.ProvisioningSettingsQueryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ProvisioningServiceErrorDetailsException<protocol.models.ProvisioningServiceErrorDetailsException>`
        """
        # Construct URL
        url = self.query_provisioning_settings.metadata["url"]

        # Construct parameters
        query_parameters = {}
        query_parameters["api-version"] = self._serialize.query(
            "self.api_version", self.api_version, "str"
        )

        # Construct headers
        header_parameters = {}
        header_parameters["Accept"] = "application/json"
        header_parameters["Content-Type"] = "application/json; charset=utf-8"
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_ms_max_item_count is not None:
            header_parameters["x-ms-max-item-count"] = self._serialize.header(
                "x_ms_max_item_count", x_ms_max_item_count, "int"
            )

        # Construct body
        body_content = self._serialize.body(query, "Query")

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ProvisioningServiceErrorDetailsException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize("ProvisioningSettingsQueryResponse", response)
            header_dict = {"x-ms-max-item-count": "int"}

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized

    query_provisioning_settings.metadata = {"url": "/provisioningSettings/query"}
